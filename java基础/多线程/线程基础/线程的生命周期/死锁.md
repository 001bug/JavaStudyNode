**线程死锁**
1.基本介绍:
多个线程都占用了对象的锁资源, 但不肯相让, 导致了死锁, 在编程时一定要避免死锁的发生

经典的死锁案例
```
package com.xinxin.syn;  
  
public class DeadLock_ {  
    public static void main(String[] args){  
        DeadLockDemo A = new DeadLockDemo(true);  
        A.setName("A线程");  
        DeadLockDemo B = new DeadLockDemo(false);  
        B.setName("B线程");  
        A.start();  
        B.start();  
    }  
}  
//线程  
class DeadLockDemo extends Thread{  
    static Object o1=new Object();//保证线程,共享一个对象  
    static Object o2=new Object();  
    boolean flag;  
    public  DeadLockDemo(boolean flag){  
        this.flag=flag;  
    }  
    @Override  
    public void run(){  
        //逻辑分析  
        //1.如果flag为T,线程A 就会先得到持o1对象锁, 然后尝试去获取o2对象锁  
        //2.如果线程A得不到o2对象锁, 就会Blocked  
        //3.如果flag为F,线程B就会先得到持有o2对象锁,然后尝试去获取o1对象锁  
        //4.如果线程B 得不到o1对象锁, 就会Blocked  
        if(flag){  
            synchronized (o1){  
                System.out.println(Thread.currentThread().getName()+"进入1");  
                synchronized (o2){//这里获得li对象的监视权  
                    System.out.println(Thread.currentThread().getName()+"进入2");  
                }  
            }  
        }  
        else{  
            synchronized (o2){  
                System.out.println(Thread.currentThread().getName()+"进入3");  
                synchronized (o1){//这里获得li对象的监视权  
                    System.out.println(Thread.currentThread().getName()+"进入4");  
                }  
            }  
        }  
    }  
}
```
在业务中尽量避免相互抢两把锁的现象