## 1逻辑架构

##### 逻辑架构剖析(运行流程)
MySQL处理一个请求的过程
![](../MySQL图解.assets/Pasted%20image%2020240713203542.png)
==MySQL官方系统结构图==
![](../MySQL图解.assets/Pasted%20image%2020240713203609.png)
1. 连接层
Connection Pool:线程池,通过tcp连接,建立交互
Management Services:基础服务组件,查询权限,类似于给请求附上token

2. 服务层
SQL Interface:SQL接口,处理SQL语句,还可以返回SQL语句的查询结果\
Parser: 解析器,对SQL语句进行语法分析,先检查词法,然后语法,返回语法树,==校验权限==
Optimizer: 查询优化器,确定执行计划,选择索引,  查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。
```
SELECT id,name FROM student WHERE gender = '女';
这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过
滤。 这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过
滤，将这两个查询条件连接起来生成最终查询结果。
```
Caches & Buffers： ==查询缓存==组件. MySQl8.0已经抛弃.比如缓存一条SELECT语句的执行结
果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过
程了，直接将结果反馈给客户端。

3. ==存储引擎层==
Storage Engines:真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作

4. 存储层:所有的数据，数据库、表的定义，表的每一行的内容，索引存在文件系统中

##### 实用查看profile
```
查看profile mysql>select @@profiling;
开启profile mysql>set profiling=1;
查看profile mysql> show profiles;//不详细
    profile mysql> show profile;//详细
指定查询 mysql> show profile for query id
```
![](../MySQL图解.assets/Pasted%20image%2020240713210332.png)不详细
![](../MySQL图解.assets/Pasted%20image%2020240713210348.png) 详细

##### 数据库缓冲池
数据库缓冲池（Database Buffer Pool）是数据库管理系统（DBMS）中用于==临时存储数据的内存区域==。它的主要目的是提高数据库系统的性能，通过减少直接从磁盘读取和写入数据的次数来加速数据访问。
![](../MySQL图解.assets/Pasted%20image%2020240713211027.png)
MyISAM存储引擎在缓冲池只是存储索引     InnoDB缓冲池是存储具体数据的

## 2存储引擎

##### 实用技巧
查看存储引擎,设定默认存储引擎

##### 存储引擎介绍
1. InnoDB 引擎:
特点:MySQL5.5往后的默认引擎,具有事务功能,除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。
对比MyISAM的存储引擎， InnoDB写的处理效率差一些，因为InnoDB不仅缓存索引还要缓存真实数据 , 所以会占用更多的磁盘空间用来保存数据和索引。文件目录有.ibd文件,存储索引和数据

2. MyISAM 引擎
MyISAM有全文索引、压缩、空间函数(GIS)等，但==MyISAM 不支持事务==、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复,
count() 的查询效率很高 , 适用只读应用或者以读为主的业务,文件目录表.frm表结构,MYD存数据,MYI存索引

3. Archive 引擎
Archive有备份/时间点恢复（在服务器中实现，而不是在存储引擎中）压缩数据,行锁 , 使用于数据存档

4. Blackhole 引擎：丢弃写操作，读操作会返回空内容
5. CSV 引擎：存储数据时，以逗号分隔各个数据项

**MyISAM和InnoDB对比**
![](../MySQL图解.assets/Pasted%20image%2020240713215417.png)

## 3索引的数据结构
##### 索引的概述以及优缺点
索引定义:索引（Index）是帮助MySQL高效获取数据的==数据结构==
**索引的优点**:1.提高数据检索的效率，降低数据库的IO成本  2.通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。3. 加速表和表之间的连接,换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。4.在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。
**索引的缺点**:（1）创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。（2）索引需要占磁盘空间 (3)降低更新表的速度,当对数据进行增加,删除,和修改时,索引也要动态的进行维护,这样就降低了数据的维护速度
**提示:在突发插入频繁的情况下，由于索引可以提高查询的速度，但是会影响插入记录的速度。这 种情况下，可以先先删除表中的索引，然后插入数据，插入完成后再创建索引。**
##### InnoDB中的索引
**InnDB中的页**
首先InnoDB的存储数据的方式是以页的形式存储的,并且一页是16kb
```
mysql> CREATE TABLE index_demo(
-> c1 INT,
-> c2 INT,
-> c3 CHAR(1),
-> PRIMARY KEY(c1)
-> ) ROW_FORMAT = Compact; c1列为主键
```
内部行格式示意图
![](../MySQL图解.assets/Pasted%20image%2020240714100549.png)
==record_type== ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、2 表示最小记
录、3 表示最大记录 , 1.目录项记录
==next_record== ：表明下一条记录是谁。
==各个列的值==：这里只记录在index_demo 表中的三个列，分别是c1 、c2 和c3 。
==其他信息==：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

一些记录(不是表)放在页中是这样的
![](../MySQL图解.assets/Pasted%20image%2020240714101048.png)

**InnoDB的数据的查找**
```
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```
1. 在一页中的查找
1.有主键的情况下,使用二分法快速查找
2.没有索引的情况下,暴力遍历

2. 在多页中的查找
1.定位到记录所在的页
2.从所在的页内中查找相应的记录。
如果没有索引,那么我们要从第一页沿着链表一直找,会非常耗时

**InnoDB中索引的建立过程**
1. 建立目录项,目录项组合在一起,形成目录页
1.目录页的各列的值记录一页中最小的主键值
2.页号,page_no, 如下
![](../MySQL图解.assets/Pasted%20image%2020240714103433.png)
随着数据不断的增多,最后会形成B+Tree的形式
![](../MySQL图解.assets/Pasted%20image%2020240714104048.png)
假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，
那么：如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100 条记录。
	   如果B+树有2层，最多能存放1000×100=10,0000 条记录。
	   如果B+树有3层，最多能存放1000×1000×100=1,0000,0000 条记录。
	   如果B+树有4层，最多能存放1000×1000×1000×100=1000,0000,0000 条记录。
所以一般不会超过四层
