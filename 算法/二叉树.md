## 递归遍历的总特性
**1.确定递归函数的参数和返回值**
**2.确定终止条件**
**3.确定单层递归的逻辑**

## 前序遍历
二叉树的前序遍历是按照根节点、左子节点、右子节点的顺序进行遍历的。下面是前序遍历的递归实现代码：

### Java 实现
##### 前序遍历

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
    }
}

public class Main {

    public void preorder(TreeNode root) {
        if (root != null) {
            // 访问根节点
            System.out.print(root.val + " ");
            // 递归遍历左子树
            preorder(root.left);
            // 递归遍历右子树
            preorder(root.right);
        }
    }

    public static void main(String[] args) {
        // 创建二叉树
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);

        // 前序遍历
        Main treeTraversal = new Main();
        treeTraversal.preorder(root);  // 输出: 1 2 4 5 3 6 7
    }
}
```
**说明**
1. **根节点**：每次递归调用时，首先访问当前节点的值（`root.val`）。
2. **左子节点**：递归调用左子树的前序遍历（`preorder(root.left)`）。
3. **右子节点**：递归调用右子树的前序遍历（`preorder(root.right)`）。
在这个示例中，给定的二叉树结构是：
```
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```
遍历输出的顺序将是：`1 2 4 5 3 6 7`。
#### 中序遍历
- 先访问左子树中的所有节点；
- 再访问当前根节点；
- 最后访问右子树中的所有节点。
```java
public void inOrder(TreeNode root) {  
    if (root == null) {  
        return;  
    }  
    // 递归访问左子树  
    inOrder(root.left);  
  
    // 访问当前节点  
    System.out.print(root.val + " ");  
  
    // 递归访问右子树  
    inOrder(root.right);  
}
```
遍历顺序输出: `4,2,5,1,6,3,7`
#### 后序遍历
- 递归访问左子树。
- 递归访问右子树。
- 访问当前节点。
```java
public void postOrder(TreeNode root) {  
    if (root == null) {  
        return;  
    }  
  
    // 递归访问左子树  
    postOrder(root.left);  
  
    // 递归访问右子树  
    postOrder(root.right);  
  
    // 访问当前节点  
    System.out.print(root.val + " ");  
}
```
遍历输出结果:`4,5,2,6,7,3`