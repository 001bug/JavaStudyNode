## 1逻辑架构

##### 逻辑架构剖析(运行流程)
MySQL处理一个请求的过程
![](assest/Pasted%20image%2020240713203542.png)
==MySQL官方系统结构图==
![](assest/Pasted%20image%2020240713203609.png)
1. 连接层
Connection Pool:线程池,通过tcp连接,建立交互
Management Services:基础服务组件,查询权限,类似于给请求附上token

2. 服务层
SQL Interface:SQL接口,处理SQL语句,还可以返回SQL语句的查询结果\
Parser: 解析器,对SQL语句进行语法分析,先检查词法,然后语法,返回语法树,==校验权限==
Optimizer: 查询优化器,确定执行计划,选择索引,  查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。
```
SELECT id,name FROM student WHERE gender = '女';
这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过
滤。 这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过
滤，将这两个查询条件连接起来生成最终查询结果。
```
Caches & Buffers： ==查询缓存==组件. MySQl8.0已经抛弃.比如缓存一条SELECT语句的执行结
果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过
程了，直接将结果反馈给客户端。

3. ==存储引擎层==
Storage Engines:真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作

4. 存储层:所有的数据，数据库、表的定义，表的每一行的内容，索引存在文件系统中

##### 实用查看profile
```
查看profile mysql>select @@profiling;
开启profile mysql>set profiling=1;
查看profile mysql> show profiles;//不详细
    profile mysql> show profile;//详细
指定查询 mysql> show profile for query id
```
![](assest/Pasted%20image%2020240713210332.png)不详细
![](assest/Pasted%20image%2020240713210348.png) 详细

##### 数据库缓冲池
数据库缓冲池（Database Buffer Pool）是数据库管理系统（DBMS）中用于==临时存储数据的内存区域==。它的主要目的是提高数据库系统的性能，通过减少直接从磁盘读取和写入数据的次数来加速数据访问。
![](assest/Pasted%20image%2020240713211027.png)
MyISAM存储引擎在缓冲池只是存储索引     InnoDB缓冲池是存储具体数据的

## 2存储引擎

##### 实用技巧
查看存储引擎,设定默认存储引擎

##### 存储引擎介绍
1. InnoDB 引擎:
特点:MySQL5.5往后的默认引擎,具有事务功能,除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。
对比MyISAM的存储引擎， InnoDB写的处理效率差一些，因为InnoDB不仅缓存索引还要缓存真实数据 , 所以会占用更多的磁盘空间用来保存数据和索引。文件目录有.ibd文件,存储索引和数据

2. MyISAM 引擎
MyISAM有全文索引、压缩、空间函数(GIS)等，但==MyISAM 不支持事务==、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复,
count() 的查询效率很高 , 适用只读应用或者以读为主的业务,文件目录表.frm表结构,MYD存数据,MYI存索引

3. Archive 引擎
Archive有备份/时间点恢复（在服务器中实现，而不是在存储引擎中）压缩数据,行锁 , 使用于数据存档

4. Blackhole 引擎：丢弃写操作，读操作会返回空内容
5. CSV 引擎：存储数据时，以逗号分隔各个数据项

**MyISAM和InnoDB对比**
![](assest/Pasted%20image%2020240713215417.png)

## 3索引的数据结构
### 索引的概述以及优缺点
#### 索引的概述
索引定义:索引（Index）是帮助MySQL高效获取数据的==数据结构==
**索引的优点**:1.提高数据检索的效率，降低数据库的IO成本  2.通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。3. 加速表和表之间的连接,换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。4.在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。
**索引的缺点**:（1）创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。（2）索引需要占磁盘空间 (3)降低更新表的速度,当对数据进行增加,删除,和修改时,索引也要动态的进行维护,这样就降低了数据的维护速度
**提示:在突发插入频繁的情况下，由于索引可以提高查询的速度，但是会影响插入记录的速度。这 种情况下，可以先先删除表中的索引，然后插入数据，插入完成后再创建索引。**
#### 聚簇索引
所有的用户记录都存在了叶子节点，数据即索引，索引即数据
**特点**
1.使用主键值的大小进行记录和页的排序
* 页内的记录是按照主键的大小顺序排成一个单向链表
* 存放用户记录的**页**也是根据页中用户记录的主键大小顺序排成一个双向链表
2.B+树的叶子节点存储的是完整的用户记录。就是指这个记录中存储了所有列的值
**优点**
* 数据访问更快, 因为聚簇索引将索引和数据保存在同一个B+树中, 减少io次数,因此从聚簇索引中获取数据比非聚簇索引更快
* 聚簇索引对于主键的排序查找和 范围查找速度非常快. 由于数据都是紧密相连,数据库不用从多个数据块中提取数据, 减少io次数
**缺点**
* 插入速度严重依赖插入顺序 , 按照主键的顺序插入是最快的方式, 否则会出现页分裂, 严重影响性能, 因此表要有自增列的id为主键
* 更新**主键**的代价很高, 更新会破坏原有的数据结构和物理存储, 一般把主键定义为不可更新
* 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据
#### 二级索引(辅助索引,非聚簇索引)
聚簇索引只能在搜索条件为主键值时才能发挥作用, B+树中的数据是按主键值排序的, 如果以其它列作为搜索条件该怎么办.
答案是多建几颗B+树
![](assest/Pasted%20image%2020240812162536.png)
[c2列](#^d642d4)的解析
**回表**:根据这个以c2列大小排序的B+树只能确定要查找记录的主键值,如果想要找出实际还要根据找出的主键值,到聚簇索引中再查一遍, 这个过程称为回表
#### 联合索引
可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序建立.  注意,本质就是二级索引
![](assest/Pasted%20image%2020240812164328.png)
### InnoDB中的索引
#### InnoDB中的页
首先InnoDB的存储数据的方式是以页的形式存储的,并且一页是16kb ^d642d4
```
mysql> CREATE TABLE index_demo(
-> c1 INT,
-> c2 INT,
-> c3 CHAR(1),
-> PRIMARY KEY(c1)
-> ) ROW_FORMAT = Compact; c1列为主键
```
内部行格式示意图
![](assest/Pasted%20image%2020240714100549.png)
==record_type== ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、2 表示最小记
录、3 表示最大记录 , 1.目录项记录
==next_record== ：表明下一条记录是谁。
==各个列的值==：这里只记录在index_demo 表中的三个列，分别是c1 、c2 和c3 。
==其他信息==：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

一些记录(不是表)放在页中是这样的
![](assest/Pasted%20image%2020240714101048.png)

#### InnoDB的数据的查找
```
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```
1. 在一页中的查找
1.有主键的情况下,使用二分法快速查找
2.没有索引的情况下,暴力遍历

2. 在多页中的查找
1.定位到记录所在的页
2.从所在的页内中查找相应的记录。
如果没有索引,那么我们要从第一页沿着链表一直找,会非常耗时

#### InnoDB中索引的建立过程
1. 建立目录项,目录项组合在一起,形成目录页
1.目录页的各列的值记录一页中最小的主键值
2.页号,page_no, 如下
![](assest/Pasted%20image%2020240714103433.png)
随着数据不断的增多,最后会形成B+Tree的形式
![](assest/Pasted%20image%2020240714104048.png)
假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，
那么：如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100 条记录。
	   如果B+树有2层，最多能存放1000×100=10,0000 条记录。
	   如果B+树有3层，最多能存放1000×1000×100=1,0000,0000 条记录。
	   如果B+树有4层，最多能存放1000×1000×1000×100=1000,0000,0000 条记录。
所以一般不会超过四层

#### InnoDB的B+树索引的注意事项
**1.跟页面位置万年不动(由上而下)**
![](assest/Pasted%20image%2020240812101730.png)

**2.内节点中目录项记录的唯一性**
内节点指非叶子节点
![](assest/Pasted%20image%2020240812104617.png)![](assest/Pasted%20image%2020240812105228.png)
![](assest/Pasted%20image%2020240812105423.png)
所以要建议把主键值也添加到二级索引内节点中的目录项记录中, 保证B+树每一层节点中各目录项记录除页号这个字段外是唯一的, 根据上面的实例, 如下是合法的有效的二级索引示意图
![](assest/Pasted%20image%2020240812110229.png)
**3.一个页面最少存2条记录**
### MyISAM中的索引方案
#### MyISAM索引的原理
InnoDB中索引即数据, 就是聚簇索引的B+树的叶子节点已经包含了用户记录, 而MyISAM的索引方案虽然是树形结构, 但是却将索引和数据分开存储, MyISAM的叶子节点存储的是主键值+数据记录地址
![](assest/Pasted%20image%2020240812154651.png)
同样也是一棵B+Tree，data域保存数据记录的地址。MyISAM中索引检索的算法为:首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址, 然后进行io操作
#### MyISAM与InnoDB对比
 1.在InnoDB存储引擎中，只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM 中需要进行一次回表操作(根据地址查找存记录的表)，所以MyISAM中建立的索引相当于全部都是二级索引。
 2.InnoDB数据和索引在同一文件, MyISAM索引和数据文件分离
 3.MyISAM的回表操作非常快速, InnoDB的回表操作需要再进行搜索,比较慢
 4.InnoDB要求表必须有主键（ MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列(已存在)作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。 
### 索引的代价
索引它在时间和空间上都会有损耗
**空间上的代价**
每建立一个索引, 都要建立一个B+树, B+树的每一个节点都是数据页, 这样一来,一棵树就需要大片的内存空间
**时间上的代价**
每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引. 因为节点的排序是有序的,增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位， 页面分裂、页面回收等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿
### MySQL数据结构选择的合理性
一般,数据结构选择的标准就是磁盘i/o操作次数
#### Hash结构
![](assest/Pasted%20image%2020240812191410.png)
![](assest/Pasted%20image%2020240812191957.png)
![](assest/Pasted%20image%2020240812192024.png)
**在上图的映射过程中, 哈希函数h有可能将两个不同的关键字映射相同的位置, 叫做碰撞 , 数据库中一般采用链接法解决 , 如下图
![](assest/Pasted%20image%2020240812192216.png)**Hash结构不作为索引结构的原因**
* Hash结构如此高效的功能,仅次于查找功能,如果进行返回查询, 就会变成O(n)
* 如果需要进行排序 , Hash是没用顺序的, 所以还要进行重新排序
* 索引列的重复值如果很多, 效率会降低, 这是因为遇到Hash冲突时, 需要遍历桶中的指针进行比较, 查找关键字, 非常耗时
![](assest/Pasted%20image%2020240812193709.png)
Hash索引的适应性
InnoDB本身是不支持Hash索引的, 但是提供自适应Hash索引. 只有在某个数据被经常访问, 当满足条件的时候, 就将这个数据页的地址存放到临时Hash表中![](assest/Pasted%20image%2020240812194357.png)
采用自适应Hash索引目的是为方便根据sql的查询条件加速定位到叶子节点, 特别是B+树层次比较深的时候
可以通过这条指令
`mysql> show variables like '%adaptive_hash_index';` 查看InnoDB是否开启了自适应Hash
#### 二叉搜索树
首先,磁盘的IO次数和索引树的高度是相关的
**二叉搜索树的特点**
* 一个节点只能有两个子节点, 也就是一个节点度不能超过2
* 左子节点<本节点; 右子节点>=本节点.
有极端的情况, 插入的顺序是单调性的, 性能上就会退化成一条链表 
![](assest/Pasted%20image%2020240812202209.png)
为了提高查询效率就需要减少磁盘IO数, 为了减少磁盘IO的次数, 就需要降低树的高度, 因此也就出现了AVL树
#### AVL树
解决了二叉树退化成链表的问题 , AVL树(平衡二叉搜索树) , 它在二叉搜索树的基础上增加了约束 
**它是一颗空树或者它的左右两个子树的高度差的绝对值不超过1 , 并且左右两个子树都是一颗平衡二叉树**
平衡二叉树包括了平衡二叉搜索树, 红黑树, 数堆, 伸展树 
当n比较大的时候,深度也会变的非常的大
![](assest/Pasted%20image%2020240812203337.png)
![](assest/Pasted%20image%2020240812203403.png)
![](assest/Pasted%20image%2020240812203412.png)
树从瘦高变为矮胖 , 性能就会提高
#### B-Tree
B树的英文是Balance Tree, 也就是多路平衡查找树. 简写为B-Tree. 它是非常的矮胖的
B树的结构
![](assest/Pasted%20image%2020240812205720.png)
B树的每一个节点, 最多包含m个子节点 , m称为B树的阶. 