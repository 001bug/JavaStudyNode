# 变量
## 变量的介绍
**变量的定义** 变量是程序的基本组成单位. 几乎所有的高级程序语言都是由(类型+名称+值)变量相当于内存中一个数据存储空间

**变量的示意图**
![](assest/Pasted%20image%2020241104210948.png)

**程序中的+号**
![](assest/Pasted%20image%2020241104211157.png)
## 数据类型
**数据类型体系图**
![](assest/Pasted%20image%2020241104211554.png)

**整数类型**
![](assest/Pasted%20image%2020241104211648.png)
细节
1.java整数类型有固定的范围和字段长度, 不受OS(操作系统)的影响, 这是为了保证java程序的可移植性
2.java的整型常量(数字) 默认是int, 如果要声明long型常量须加`l`或`L`

**浮点类型**
![](assest/Pasted%20image%2020241104212030.png)
细节
1.浮点数在机器中存放形式: 浮点数=符号位+指数位+尾数位
2.尾数位部分可能会丢失, 造成精度损失
3.java的浮点型常量默认是double型, 声明float型常量, 须在其后加`f`或`F`
4.浮点数的表达形式
* 十进制数形式: 如 5.12  512.0f
* 科学技术法形式如: `5.12e2(5.12*10^2)` `5.12E-2(5.12/10^2)`
5.浮点数使用陷阱: 2.7和8.1/3比较(2.7大)
因为浮点数是以二进制形式存储, 十进制的小数无法精确地转换成二进制. 这会引起一定的精度误差.因此要有一个容错范围
```
double num1=2.7;
double num2=8.1;
if(Math.abs(num1-num2)<1E-9)
```

**字符类型**
char ---- 两个字节(可以存放汉字)
使用细节
1.char本质是整数,是对应的unicode码`(int)c1`
2.可以直接给char赋值整数,然后输出是对应的unicode的字符
3.unicode装换工具:http://tool.chinaz.com/Tools/Unicode.aspx
4.char类型可以运算
5.字符编码
* ASCII一个字节表示,一个字节表示128个字符,理论上一个字节可以组合`2^8` 的字符,但是ASCII只用一个
* Unicode固定编码大小, 两个字节表示
* utf-8, 大小可变,字母用1个, 汉字用3个
* gbk , 可以表示汉字, 字母用1个, 汉字2个

**布尔类型**
## 基本数据类型的转换和String类型的转换
**基本数据类型的转换**
1.自动类型转换
![](assest/Pasted%20image%2020241105092911.png)
浮点数具有小数的表达能力, 自然比整数的精度高
细节
* 多种数据类型混合运算,系统先将所有数据转换成精度大的数据类型,然后计算
* [byte,short和char之间不会相互自动转换. 他们三者可以相互计算,在**计算**时首先转换成Int类型.](细节解释)
* boolean不参与转换
* 自动提升原则: 表达式结果的类型自动提升为操作数中最大的类型

2.强制类型转换
细节
* 当进行数据的精度大小从大-->小 , 就需要使用到强制类型转换
* char类型可以保存int的常量值,但不能保存int的变量值.(编译器类型检查机制和char的取值范围限制)
```java
char c1=100;
int m=100;
char c2=m;//错误
```
**JDK类的组织形式**
![](assest/Pasted%20image%2020241105091252.png)

**基本数据类型和String类型的转换**
1.基本介绍和使用
* 基本类型转String类型: 将基本数据类型+""即可
* String类型转基本数据类型: 通过基本类型的包装类调用parseXX方法,要保证是有效的整数, 如果格式错误,它会抛出异常
# 运算符
**关系运算符**
`instanceof`检查是否是类的对象比如 , `"string" instanceof String`

**逻辑运算符**
介绍: 用于连接多个条件, 最终的结果也是一个boolean值
(1)短路与`&&` , 短路或`||` , 取反`!`
(2)逻辑与`&` , 逻辑或`|` , 逻辑异或`^`
![](assest/Pasted%20image%2020241105123720.png)
短路和逻辑的区别 
* 短路: 当第一个条件为false是,第二个条件不用运算
* 逻辑: 即使第一个条件为false, 都要对第二个条件进行判断

**三元运算符**
基本语法: `条件表达式?表达式1:表达式2`
1.如果条件表达式为true，运算后的结果是表达式1；
2.如果条件表达式为false，运算后的结果是表达式2；

**关键字**
是在java程序中提前被保留下来的
![](assest/Pasted%20image%2020241105124905.png)
![](assest/Pasted%20image%2020241105124909.png)

**键盘输入语句**
1.Scanner类表示简单文本扫描器, 在new一个Scanner实例的时候要引入参数System.in
2.Scanner的常用方法
* next() 读取下一个单词(一空格或换行分隔符的字符串)
* `nextLine()`: 读取一整行, 直到行结束(包括空格)
* nextInt(): 读取下一个int类型整数值
* `nextDouble()`读取下一个双精度浮点数
* `close()`: 关闭`Scanner`对象,释放资源
# 数组,排序,查找
## 数组
**数组赋值机制**
1.基本数据类型赋值, 这个值就是具体的数据 , 相互不影响(值拷贝)
```java
int n1=2;
int n2=n1;
n2=80;//n1还是2, n2变为80
```
2.数组在默认情况下是引用传递, 赋的值是地址
![](assest/Pasted%20image%2020241105161817.png)
解释
上面是数组的浅拷贝, 是指在拷贝数组时，只拷贝了数组的引用，而不是数组中的实际数据。他们共享一个对象的引用
浅拷贝的方法
* 使用`System.arraycopy()` , `Arrays.copyOf()`, array2 = array1(直接赋值)

深拷贝
深拷贝（Deep Copy）是指在拷贝数组时，不仅拷贝了数组本身的内容，还递归地拷贝了数组中的每个对象，从而创建完全独立的副本
深拷贝的方法
* 手动遍历并创建每个元素的副本
* 使用序列化和反序列化
```java
public static <T> T deepCopy(T object) {  
    T copiedObject = null;  
    try {  
        // 将对象写入字节流  
        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();  
        ObjectOutputStream out = new ObjectOutputStream(byteOut);  
        out.writeObject(object);  
        out.flush();  
  
        // 从字节流中读出对象  
        ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());  
        ObjectInputStream in = new ObjectInputStream(byteIn);  
        copiedObject = (T) in.readObject();  
    } catch (IOException | ClassNotFoundException e) {  
        e.printStackTrace();  
    }  
    return copiedObject;  
}
```

**数组的扩容**
1.定义新数组`int[] ar=new int[arr.length+1]`, 然后深拷贝
# 面向对象基础
## 类和对象
**类和对象的关系示意图**
![](assest/Pasted%20image%2020241105165953.png)
![](assest/Pasted%20image%2020241105170006.png)
解释
* 类是抽象的, 代表着一类事务 , 比如人类, 计算机, 即他是数据类型
* 对象是具体的 , 实际的. 按照类的模版产生 , 比如 ,小明 , 猫
* 类是对象的模版, 对象是类的一个个个体

**对象在内存中存在的形式**
![](assest/Pasted%20image%2020241105170212.png)
类的组成成分: 字段,属性(任意数据类型)

**类和对象的内存分配机制**
1.java内存的结构分析
* 栈: 一般存放基本数据类型(局部变量)
* 堆: 存放对象(Cat cat , 数组等)
* 方法区: 常量池(常量,比如字符串) , 类加载信息
## 方法
**方法的调用机制原理**
![](assest/Pasted%20image%2020241105171218.png)

**方法的好处**
提高代码的复用性
可以将实现的细节封装起来 , 然后供其他用户来调用即可

**方法的递归调用**
递归就是方法自己调用自己. 
* 执行一个方法时, 就创建一个新的受保护的独立空间(栈空间)
* 方法的局部变量是独立的,不会受到影响
* 方法中的引用数据类型(如数组,对象), 就会共享该引用类型的数据
* 当一个方法执行完毕 , 或遇到return , 就会返回, 遵守谁调用谁 , 就将结果返回给谁, 同时该方法消失

**方法重载**
java允许同一个类中, 多个同名方法的存在 , 但要求 , 形参列表不一致
意义: 减轻了起名的麻烦和记名的麻烦

**可变参数**
定义: java允许将同一个类中多个同名同功能但**参数个数不同**的方法,封装成一个方法, 通过可变参数实现
基本语法
```
访问修饰符 返回类型 方法名(数据类型... 形参名){

}
```
细节以及注意事项
1.可变参数的实参可以为0个或任意多个
2.实参可以为数组, 可变参数本质就是数组, 可以以数组的形式遍历
3.可变参数和普通类型参数放在一起作为形参列表时, 必须保证可变参数在最后
4.==一个形参列表只能出现一个可变参数.==
# 并发

# 流与文件
![](Java高级/assest/Pasted%20image%2020240913190845.png)
## 流
**1.1流**
输入流: 能够读字节序列的对象
输出流: 能够输出字节序列的对象
字节流: `InputStream`和`OutputStream`构成有层次结构的输入/输出(I/O)类的基础
字符流: [面向字节的流不便于处理Unicode形式]([](字符流)), 所以从抽象类`Reader`和`Writer`中继承出来专门处理Unicode字符的类单独构成一个独立的层次结构. 这些类拥有的读入和写出操作都是基于两字节的Unicode码元.
**`read`** 和 **`write`** 方法在进行输入输出操作时，如果没有立即获得所需的数据（如在读取数据时流中暂时没有数据，或者在写入数据时目标设备未准备好），当前线程会**暂停**，直到数据准备好，操作才能继续。这段暂停的时间称为“阻塞”，它使得当前线程无法继续执行，直到完成输入或输出操作。
