异常处理就是当异常发生时,对异常处理的方式

**异常处理的方式**
1. **try-catch-finally**
   程序员在代码中捕获发生的[[异常]], 自行处理
```
try{
代码/可能有异常
}catch(Exception e){
//捕获到异常
//1.当异常发生时
//2.系统将异常封装成Exception对象e, 传递给cath,得到异常对象后,程序员自己处理....如果没有发生异常cath代码块不执行
}finally{
//1.不管try代码块是否有异常发生,始终要执行finally,一般在这里放释放资源的代码
}
```
try-catch方式处理异常
1.如果异常发生了,则异常发生后面的代码不会执行,直接进入到catch块.
2.如果异常没有发生, 则顺序执行try的代码块, 不会进入到catch
3.如果希望不管是否发生异常, 都执行某段代码(比如关闭连接, 释放资源)则用finally{}
4.可以进行try-finally配合使用, 这种用法相当于没有捕获异常, 因此程序会直接崩掉. 应用场景, 就是执行一段代码, 不管是否发生异常, 都必须执行某个业务逻辑
```
try{
//代码
}
finally{//总是执行
}
```
![[Pasted image 20240224175129.png]]
2. **throws**
   将发生的异常抛出, 交给==调用者==(方法)来处理, 最顶级的处理者就是JVM
   ![[Pasted image 20240224170800.png]]
   基本介绍
   1. 如果一个方法(中的语句执行时)可能生成某种异常, 但是并不能确定如何处理这种异常,  则此方法应显示地声明抛出异常, 表明该方法将不对这些异常进行处理, 而由该方法的调用者负责处理
   2. 在方法声明中用throws语句可以声明抛出异常的列表, throws后面的异常类型可以是方法中产生的异常类型, 也可以是它的父类.
```
package com.xinxin.thorw;  
  
import java.io.FileInputStream;  
import java.nio.file.FileAlreadyExistsException;  
  
public class thorw_ {  
    public static void main(String[] args){  
          
    }  
    public  void f1() throws FileAlreadyExistsException{  
    //1.这里的异常是一个FileNotFoundException编译异常
    //2.使用throws , 抛出异常,让调用f1方法的调用者(方法)处理
    //3.throws后面的异常类型可以是方法中产生的异常类型,也可以是它的父类
    //5.throws关键字后也可以是异常列表, 既可以抛出多个异常,比如现在加上
    //NullPointerException算数异常
        FileInputStream fileInputStream = new FileInputStream("d://a.txt");  
    }  
}
```

throws异常处理
1. 对于编译异常, 程序中必须处理, 比如try-catch或者throws
2. 对于运行时异常, 程序中如果没有处理,默认就是throws的方式处理
3. 子类重写父类的方法时,对抛出异常的规定: 子类重写的方法, 所抛出的异常类型要么和父类抛出的异常一致,要么为父类抛出的异常的类型的子类型
4. 在throws过程中,如果有方法try-catch, 就相当于处理异常, 就可以不必throws