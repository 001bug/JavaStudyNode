1.在多线程编程, 一些敏感数据不允许被多个线程同时访问, 此时就使用同步访问技术,保证数据在任何同一时刻, 最多只有一个线程访问, 以保证数据的完整性

2.也可以这样理解: 线程同步, 即当有一个线程在对内存进行操作时, 其它线程都不可以对这个内存地址进行操作, 直到该线程完成操作, 其它线程才能的该内存地址进行操作

**同步具体实现方法-Synchronized**
1. 同步代码块
```
synchronized(对象){//得到对象的锁, 才能操作同步代码
	//需要被同步代码;
}
2.
synchronized还可以放在方法声明中, 表示整个方法-为同步方法
public synchronized void m(String name){
	//需要被同步的代码
}
```

**线程的同步机制原理**
![[Pasted image 20240303190043.png]]

**互斥锁**
1. Java在Java语言中, 引入了对象互斥锁的概念, 来保证共享数据操作的完整性
2. 每个对象都对应于一个可称为"互斥锁"的标记, 这个标记用来保证在任一时刻,只能有一个线程访问该对象.
3. 关键字synchronized来与对象的互斥锁联系, 当某个对象用synchronized修饰时, 表明该对象在任一时刻只能由一个线程访问
4. 同步的局限性: 导致程序的执行效率要降低
5. 同步方法(非静态)的锁可以是this,也可以是其他对象(要求是同一个对象)
6. 同步方法(静态的)的锁为当前类本身

**线程死锁**
1.基本介绍:
多个线程都占用了对象的锁资源, 但不肯相让, 导致了死锁, 在编程时一定要避免死锁的发生

经典的死锁案例
```
package com.xinxin.syn;  
  
public class DeadLock_ {  
    public static void main(String[] args){  
        DeadLockDemo A = new DeadLockDemo(true);  
        A.setName("A线程");  
        DeadLockDemo B = new DeadLockDemo(false);  
        B.setName("B线程");  
        A.start();  
        B.start();  
    }  
}  
//线程  
class DeadLockDemo extends Thread{  
    static Object o1=new Object();//保证线程,共享一个对象  
    static Object o2=new Object();  
    boolean flag;  
    public  DeadLockDemo(boolean flag){  
        this.flag=flag;  
    }  
    @Override  
    public void run(){  
        //逻辑分析  
        //1.如果flag为T,线程A 就会先得到持o1对象锁, 然后尝试去获取o2对象锁  
        //2.如果线程A得不到o2对象锁, 就会Blocked  
        //3.如果flag为F,线程B就会先得到持有o2对象锁,然后尝试去获取o1对象锁  
        //4.如果线程B 得不到o1对象锁, 就会Blocked  
        if(flag){  
            synchronized (o1){  
                System.out.println(Thread.currentThread().getName()+"进入1");  
                synchronized (o2){//这里获得li对象的监视权  
                    System.out.println(Thread.currentThread().getName()+"进入2");  
                }  
            }  
        }  
        else{  
            synchronized (o2){  
                System.out.println(Thread.currentThread().getName()+"进入3");  
                synchronized (o1){//这里获得li对象的监视权  
                    System.out.println(Thread.currentThread().getName()+"进入4");  
                }  
            }  
        }  
    }  
}
```
在业务中尽量避免相互抢两把锁的现象